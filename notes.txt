I am going to figure out what the training data looks like.
observations = [3 elements] in snake_nn [obstacles to left, front, right]
observations = [4 elements] in snake_nn2 [obstacles to left, front, right, normalized angle to food]
at each step, a training data set is being appended to a training data array (starting as empty) []

                if done:
                    training_data.append([self.add_action_to_observation(prev_observation, action), 0])
                    break
                else:
                    training_data.append([self.add_action_to_observation(prev_observation, action), 1])

I know  where this is happening but I do not know how it is exactly laid out.



In order to make this neural network generator
    - Adding a Feature to the Game 
        IN SNAKE

        - Physically putting the feature into the game
            - Add randomly generated obstacles
            
            - Return the position of these obstacles when generating observations in the game.
                generate observations in snake.py = self.done, self.score, self.snake, self.food
                maybe add self.obstacles
        
        IN SNAKE_NN
            - Updating the Shape of the data that is used for training.
            
            - Fitting the the data to the model (see train_model). This should just work once we reshape the data appropiately.
            
            - No updates should be necessary to the iniital_population function, so long as the observations generated by the game are updated.
            - Update Generate_observations to include obstacles
            - Also update is_direction_blocked to check for additional obstacles that aren't just the edges of the map + the snake itself


self.snake is important


Training_data is laid out as:

[[nparray( action taken, observation1, observation2, obs3, obs4, etc...), RESULT OF ACTION]] 